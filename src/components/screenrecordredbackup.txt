import React, { Component } from 'react';
//@ts-ignore
import RecordRTC, { MediaStreamRecorder, RecordRTCPromisesHandler } from 'recordrtc';

import {
    getAllVideoMetaData,
    getVideo,
    sendVideoViaSocketIO,
    socket,
    socStream
} from './ScreenRecorderApi';
import { v4 as uuidv4 } from 'uuid';
import { VideoData } from './VideoData';
import { batchDurationInSeconds, videoDurationInSeconds } from '../constants/Constants';
import { VideoMetadata } from './VideoMetadata';
import VideoPlayerComponent from './VideoPlayerComponent';

interface ScreenRecorderProps {
}

interface ScreenRecorderState {
    // @ts-ignore
    recorder: RecordRTC | null;
    stream: MediaStream | null;
    type: RecordType | null;
    batchCounter: number;
    activeRecordingSessionVideoName: string;
    startingTimeOfActiveRecordingSession: string;
    videoMetaDataList: VideoMetadata[];
    videoUrl: string;
}

type RecordType = 'video' | 'screen';

class ScreenRecorder extends Component <ScreenRecorderProps, ScreenRecorderState> {

    constructor(props: ScreenRecorderProps) {
        super(props);
        this.startRecording = this.startRecording.bind(this);
        this.stopRecording = this.stopRecording.bind(this);
        this.onBlobAvailable = this.onBlobAvailable.bind(this);
        this.state = {
            recorder: null,
            stream: null,
            type: 'screen',
            batchCounter: 0,
            activeRecordingSessionVideoName: null,
            startingTimeOfActiveRecordingSession: null,
            videoMetaDataList: [],
            videoUrl: ''
        };
    }

    componentDidMount() {
        this.subscribeToScreenRecorderAPI();
        getAllVideoMetaData();
    }

    handleSocketConnection(updatedVideoDurationInSeconds, updatedBatchDurationInSeconds): any {
        if (socket) {
            socket.on('getAllVideoMetaData_result', (payload) => {
                let data: VideoMetadata[] = JSON.parse(payload);
                if (data.length > 0) {
                    console.log('getAllVideoMetaData_result incoming ');
                    data.forEach(dataItem => {
                        console.log('getAllVideoMetaData_result---->' + dataItem.fileName);
                    });
                    this.setState({ videoMetaDataList: data });
                } else {
                    console.log('No Videos have been found on the server');
                }
            });

            socket.on('uploadFile_res', (payload) => {
                console.log(payload);
                getAllVideoMetaData();
            });
            socket.on('uploadBatch_res', (payload) => {
                console.log(payload);
            });
            socket.on('removeFile_ack', (payload) => {
                console.log(payload);
            });

            socket.on('downloadFile_ack', (payload) => {
                console.log(payload);
            });

            socket.on('error', (payload) => {
                console.log(payload);
            });

            socket.on('disconnect', (payload) => {
                console.log(payload);
            });

            socket.on('connect_error', (payload) => {
                console.log(payload);
            });

            socket.on('connection', () => {
                console.log(`Connected with the back-end`);
                socket.emit('updateRecordingParameters',
                    JSON.stringify({ updatedVideoDurationInSeconds, updatedBatchDurationInSeconds }));
            });

            socket.on('heartbeat', () => {
                socket.emit('heartbeat', 'ack');
                console.log('heartbeat');
            });
        }
    }

    subscribeToScreenRecorderAPI() {
        this.handleSocketConnection(videoDurationInSeconds, batchDurationInSeconds);
    }

    sendVideoBlobToScreenRecorderApi(blob, videoData: VideoData) {
        sendVideoViaSocketIO(blob,
            videoData.fileName,
            videoData.videoStartingDate,
            videoData.videoDuration,
            videoData.orderInBatch);
    }

    generateTimeSignature(): string {
        let startingTimeOfActiveRecordingSession: string = '';
        let date: Date = new Date();
        startingTimeOfActiveRecordingSession =
            date.getFullYear() + '_' +
            date.getMonth() + '_' +
            date.getDay() + '_' +
            date.getHours() + '_' +
            date.getMinutes() + '_' +
            date.getSeconds();
        this.setState({ startingTimeOfActiveRecordingSession });
        return startingTimeOfActiveRecordingSession;
    }

    generateVideoNameWithDateAndUUID(): string {
        let activeRecordingSessionVideoName = this.generateTimeSignature() + '__' + uuidv4();
        activeRecordingSessionVideoName = uuidv4();
        this.setState({ activeRecordingSessionVideoName });
        return activeRecordingSessionVideoName;
    }

    resetBlobCounter(): void {
        const blobCounter = videoDurationInSeconds / batchDurationInSeconds;
        this.setState({ batchCounter: blobCounter });
    }

    onBlobAvailable(blob: Blob) {
        if (this.state.batchCounter === 0) {
            //New video, setting new parameters or it
            this.resetBlobCounter(); // resets the defualt value\
            this.generateVideoNameWithDateAndUUID();
            //blob = new Blob([blob],
              //  { type: 'video/webm;codecs=h264' })
            console.log(blob.type);
            blob = blob.slice(0,blob.size,'video/webm;codecs=h264' );
        }
        const videoData: VideoData = {
            fileName: this.state.activeRecordingSessionVideoName,
            videoStartingDate: this.state.startingTimeOfActiveRecordingSession,
            videoDuration: videoDurationInSeconds,
            orderInBatch: this.state.batchCounter
        };
        // this.state.recorder.getSeekableBlob(blob, (seekableBlob)=>{
        //     this.sendVideoBlobToScreenRecorderApi(blob, videoData);
        // })

        this.sendVideoBlobToScreenRecorderApi(blob, videoData);

        this.setState(prevState => ({
            batchCounter: prevState.batchCounter - 1
        }));
    }

    onRecordStateChange(state: string) {
        console.log(state);
        debugger;
    }

    async startRecording() {
        let stream = await (navigator.mediaDevices as any).getDisplayMedia({ video: true, audio: true });
        let recorder = new RecordRTCPromisesHandler(stream, {
            type: 'video',
            mimeType: 'video/webm;codecs=h264',
            frameRate: 15,
            timeSlice: 1000 * batchDurationInSeconds,
            ondataavailable: this.onBlobAvailable,
            disableLogs: false,
        });
        recorder.recordRTC.onStateChanged = (state) => {
            this.onRecordStateChange(state);
        };
        recorder.onStateChanged = function (state) {
            console.log('Recorder state: ', state);
            debugger;
        };
        this.setState({
            stream: stream
        });
        this.setState({
            recorder: recorder
        });
        recorder.startRecording();
        /*
       const recorder: RecordRTC = new RecordRTC(stream, {
           // audio, video, canvas, gif
           type: 'video',
           timeSlice: 1000,

           // audio/webm
           // video/webm;codecs=vp9
           // video/webm;codecs=vp8
           // video/webm;codecs=h264
           // video/x-matroska;codecs=avc1
           // video/mpeg -- NOT supported by any browser, yet
           // video/mp4  -- NOT supported by any browser, yet
           // audio/wav
           // audio/ogg  -- ONLY Firefox
           // demo: simple-demos/isTypeSupported.html
           mimeType: 'video/webm;codecs=h264',

           // MediaStreamRecorder, StereoAudioRecorder, WebAssemblyRecorder
           // CanvasRecorder, GifRecorder, WhammyRecorder
           recorderType: MediaStreamRecorder,

           // disable logs
           disableLogs: true,

           // get intervals based blobs
           // value in milliseconds
           timeSlice: 1000,

           // requires timeSlice above
           // returns blob via callback function
           ondataavailable: function(blob) {},

           // auto stop recording if camera stops
           checkForInactiveTracks: false,

           // requires timeSlice above
           onTimeStamp: function(timestamp) {},

           // both for audio and video tracks
           bitsPerSecond: 128000,

           // only for audio track
           audioBitsPerSecond: 128000,

           // only for video track
           videoBitsPerSecond: 128000,

           // used by CanvasRecorder and WhammyRecorder
           // it is kind of a "frameRate"
           frameInterval: 90,

           // if you are recording multiple streams into single file
           // this helps you see what is being recorded
           previewStream: function(stream) {},


           // used by CanvasRecorder and WhammyRecorder
           canvas: {
               width: 640,
               height: 480
           },

           // used by StereoAudioRecorder
           // the range 22050 to 96000.
           sampleRate: 96000,

           // used by StereoAudioRecorder
           // the range 22050 to 96000.
           // let us force 16khz recording:
           desiredSampRate: 16000,

           // used by StereoAudioRecorder
           // Legal values are (256, 512, 1024, 2048, 4096, 8192, 16384).
           bufferSize: 16384,

           // used by StereoAudioRecorder
           // 1 or 2
           numberOfAudioChannels: 2,

           // used by WebAssemblyRecorder
           frameRate: 30,

           // used by WebAssemblyRecorder
           bitrate: 128000,

           // used by MultiStreamRecorder - to access HTMLCanvasElement
           elementClass: 'multi-streams-mixer'

        });
        */
    }

    async stopRecording() {
        const recorder = this.state.recorder;
        if (recorder) {
            await recorder.stopRecording();
            const blob: Blob = await recorder?.getBlob();
            let videoUrl = URL.createObjectURL(blob);
            this.setState(prevState => ({
                videoUrl
            }));
            (this.state.stream as any).stop();
            this.setState({
                recorder: null
            });
            this.setState({
                stream: null
            });
        }
    }

    getVideo(id: string): void {
        if (id) {
            if (socket) {
                console.log('getVideoSent: ' + id);
                socket.emit('getVideo', id);
            }
        }
    }

    downloadVideo() {
        getVideo(this.state.activeRecordingSessionVideoName);
    }

    render(): JSX.Element {
        return <div>
            <button onClick={this.startRecording.bind(this)}>
                startRecording
            </button>
            <button onClick={this.stopRecording.bind(this)}>
                stopRecording
            </button>
            <button onClick={this.downloadVideo.bind(this)}>
                download
            </button>
            <button onClick={getAllVideoMetaData.bind(this)}>
                getAll
            </button>
            <video src={this.state.videoUrl} width="200" height="200" controls/>
            <VideoPlayerComponent videoMetaData={this.state.videoMetaDataList}>
            </VideoPlayerComponent>
        </div>;
    }

}

export default ScreenRecorder;
